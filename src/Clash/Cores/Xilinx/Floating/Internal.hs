{-|
Copyright  :  (C) 2021,      QBayLogic B.V.,
License    :  BSD2 (see the file LICENSE)
Maintainer :  QBayLogic B.V. <devops@qbaylogic.com>
-}

{-# LANGUAGE DeriveLift #-}
{-# LANGUAGE LambdaCase #-}

{-# OPTIONS_HADDOCK hide #-}

{-# OPTIONS_GHC -fconstraint-solver-iterations=10 #-}

module Clash.Cores.Xilinx.Floating.Internal
  ( Config(..)
  , ArchOpt(..)
  , archOptToTcl
  , DspUsage(..)
  , dspUsageToTcl
  , BMemUsage(..)
  , bMemUsageToTcl
  , Ordering(..)
  , xilinxNaN
  , conditionFloat
  , conditionFloatF
  , xilinxCompare
  , toMaybeOrdering
  , binaryInst
  ) where

import Clash.Prelude hiding (Ordering(..))
import qualified Prelude as P

import Clash.Cores.Xilinx.Xpm.Cdc.Internal

import qualified Clash.Signal.Delayed as D

import Clash.Annotations.BitRepresentation.Deriving
  ( deriveAnnotation, simpleDerivator, ConstructorType(OneHot), FieldsType(Wide)
  , deriveBitPack )

-- | Customize Xilinx floating point IP.
--
-- These customizations influence how the IP will be synthesized. They do not
-- affect behavior.
data Config = Config
  { archOpt :: !ArchOpt
    -- ^ Architecture optimizations
  , dspUsage :: !DspUsage
    -- ^ DSP slice usage
  , bMemUsage :: !BMemUsage
    -- ^ Use block memory for exponential function
  } deriving (Eq, Show)

-- | Architecture optimizations.
--
-- For those operations that support different architecture optimizations.
data ArchOpt
  = SpeedArch
    -- ^ Speed-optimized architecture
  | LatencyArch
    -- ^ Low latency architecture
  deriving (Eq, Show)

archOptToTcl :: ArchOpt -> String
archOptToTcl = \case
  SpeedArch -> "Speed_Optimized"
  LatencyArch -> "Low_Latency"

-- | DSP slice usage.
--
-- For those operations that can use DSP slices. Not all such operations support
-- all variants.
data DspUsage
  = NoDspUsage
    -- ^ Do not use any DSP slices
  | MediumDspUsage
  | FullDspUsage
  | MaxDspUsage
  deriving (Eq, Show)

dspUsageToTcl :: DspUsage -> String
dspUsageToTcl = \case
  NoDspUsage -> "No_Usage"
  MediumDspUsage -> "Medium_Usage"
  FullDspUsage -> "Full_Usage"
  MaxDspUsage -> "Max_Usage"

-- | Block memory usage.
--
-- Configures whether the exponential operator uses block memory.
data BMemUsage
  = NoBMemUsage
    -- ^ Do not use block memory
  | FullBMemUsage
    -- ^ Use block memory
  deriving (Eq, Show)

bMemUsageToTcl :: BMemUsage -> String
bMemUsageToTcl = \case
  NoBMemUsage -> "No_Usage"
  FullBMemUsage -> "Full_Usage"

-- | NaN as generated by Xilinx.
--
-- Quiet NaN, no payload, positive.
xilinxNaN :: Float
xilinxNaN = unpack 0x7FC00000

-- | Perform the same conditioning on a Float as the Xilinx IP does.
--
-- All NaNs are mapped to 'xilinxNaN', all subnormal numbers to zero.
--
-- Note that there are a few exceptions where the Xilinx IP does not condition
-- Float values. Those functions are documented as such.
--
-- __NB__: Not synthesizable
conditionFloat
  :: Float
  -> Float
conditionFloat x
  | isNaN x          = xilinxNaN
  | isDenormalized x = if x > 0 then 0 else -0
  | otherwise        = x

-- | Perform the same conditioning on a Float as the Xilinx IP does.
--
-- 'conditionFloat' lifted to 'Functor'.
--
-- __NB__: Not synthesizable
conditionFloatF
  :: Functor f
  => f Float
  -> f Float
conditionFloatF = fmap conditionFloat

-- | One-hot encoded version of 'P.Ordering'. The order of fields is chosen to
-- match the ordering picked by Xilinx's Floating Point comparison IP.
data Ordering
  = EQ
  | LT
  | GT
  | NaN
  deriving (Generic, NFDataX, Eq, ShowX, Show, Lift)
deriveAnnotation (simpleDerivator OneHot Wide) [t| Ordering |]
deriveBitPack [t| Ordering |]

-- | Converts 'Ordering' to Prelude's 'P.Ordering'. If the given ordering is
-- 'NaN', 'Nothing' is returned.
toMaybeOrdering :: Ordering -> Maybe P.Ordering
toMaybeOrdering = \case
  EQ -> Just P.EQ
  LT -> Just P.LT
  GT -> Just P.GT
  NaN -> Nothing

-- | Perform comparison on two 'Float's. The type returned is a locally defined
-- version of 'Ordering'. If you want prelude's 'P.Ordering', see 'toMaybeOrdering'.
xilinxCompare :: Float -> Float -> Ordering
xilinxCompare x y
  | isNaN x = NaN
  | isNaN y = NaN
  | otherwise =
      case compare (conditionFloat x) (conditionFloat y) of
        P.LT -> LT
        P.EQ -> EQ
        P.GT -> GT

binaryInst ::
  forall d nExtraOpts n dom .
  (KnownNat nExtraOpts, KnownDomain dom, KnownNat d) =>
  -- | Instantiation type hint
  String ->
  -- | @CONFIG.Operation_Type@. E.g., @Divide@.
  String ->
  -- | Extra Wizard options (will be added to the default ones)
  Vec nExtraOpts (OptionName, XilinxWizardOption) ->
  Clock dom ->
  Enable dom ->
  DSignal dom n Float ->
  DSignal dom n Float ->
  DSignal dom (n + d) Float
binaryInst nm operType extraOptions clk ena a b =
  D.unsafeFromSignal $ unpack <$> unPort (snd go)
 where
  go ::
    ( Port "m_axis_result_tvalid" dom Bit
    , Port "m_axis_result_tdata" dom (BitVector 32)
    )
  go =
    instWithXilinxWizard
      (instConfig nm)
      (XilinxWizard
        { wiz_name = "floating_point"
        , wiz_vendor = "xilinx.com"
        , wiz_library = "ip"
        , wiz_version = "7.1"
        , wiz_options =
             ("CONFIG.Operation_Type",     StrOpt operType)
          :> ("CONFIG.Flow_Control",       StrOpt "NonBlocking")
          :> ("CONFIG.Has_ACLKEN",         BoolOpt True)
          :> ("CONFIG.Has_RESULT_TREADY",  BoolOpt False)
          :> ("CONFIG.Maximum_Latency",    BoolOpt False)
          :> ("CONFIG.C_Latency",          IntegerOpt (natToNum @d))
          :> extraOptions
        })
        (ClockPort @"aclk" clk)
        (Port @"aclken" (boolToBit <$> fromEnable ena))
        (Port @"s_axis_a_tdata" (pack <$> D.toSignal a))
        (Port @"s_axis_a_tvalid" (pure 1 :: Signal dom Bit))
        (Port @"s_axis_b_tdata" (pack <$> D.toSignal b))
        (Port @"s_axis_b_tvalid" (pure 1 :: Signal dom Bit))
{-# INLINE binaryInst #-}
