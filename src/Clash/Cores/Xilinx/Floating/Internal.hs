{-|
Copyright  :  (C) 2021,      QBayLogic B.V.,
License    :  BSD2 (see the file LICENSE)
Maintainer :  QBayLogic B.V. <devops@qbaylogic.com>
-}

{-# LANGUAGE DeriveLift #-}
{-# LANGUAGE LambdaCase #-}

module Clash.Cores.Xilinx.Floating.Internal
  ( Config(..)
  , ArchOpt(..)
  , DspUsage(..)
  , BMemUsage(..)
  , Ordering(..)
  , xilinxNaN
  , conditionFloat
  , conditionFloatF
  , xilinxCompare
  , toMaybeOrdering
  ) where

import Clash.Prelude hiding (Ordering(..))
import qualified Prelude as P

import Clash.Annotations.BitRepresentation.Deriving
  ( deriveAnnotation, simpleDerivator, ConstructorType(OneHot), FieldsType(Wide)
  , deriveBitPack )

-- | Customize Xilinx floating point IP.
--
-- These customizations influence how the IP will be synthesized. They do not
-- affect behavior.
data Config = Config
  { archOpt :: !ArchOpt
    -- ^ Architecture optimizations
  , dspUsage :: !DspUsage
    -- ^ DSP slice usage
  , bMemUsage :: !BMemUsage
    -- ^ Use block memory for exponential function
  } deriving (Eq, Show)

-- | Architecture optimizations.
--
-- For those operations that support different architecture optimizations.
data ArchOpt
  = SpeedArch
    -- ^ Speed-optimized architecture
  | LatencyArch
    -- ^ Low latency architecture
  deriving (Eq, Show)

-- | DSP slice usage.
--
-- For those operations that can use DSP slices. Not all such operations support
-- all variants.
data DspUsage
  = NoDspUsage
    -- ^ Do not use any DSP slices
  | MediumDspUsage
  | FullDspUsage
  | MaxDspUsage
  deriving (Eq, Show)

-- | Block memory usage.
--
-- Configures whether the exponential operator uses block memory.
data BMemUsage
  = NoBMemUsage
    -- ^ Do not use block memory
  | FullBMemUsage
    -- ^ Use block memory
  deriving (Eq, Show)

-- | NaN as generated by Xilinx.
--
-- Quiet NaN, no payload, positive.
xilinxNaN :: Float
xilinxNaN = unpack 0x7FC00000

-- | Perform the same conditioning on a Float as the Xilinx IP does.
--
-- All NaNs are mapped to 'xilinxNaN', all subnormal numbers to zero.
--
-- Note that there are a few exceptions where the Xilinx IP does not condition
-- Float values. Those functions are documented as such.
--
-- __NB__: Not synthesizable
conditionFloat
  :: Float
  -> Float
conditionFloat x
  | isNaN x          = xilinxNaN
  | isDenormalized x = if x > 0 then 0 else -0
  | otherwise        = x

-- | Perform the same conditioning on a Float as the Xilinx IP does.
--
-- 'conditionFloat' lifted to 'Functor'.
--
-- __NB__: Not synthesizable
conditionFloatF
  :: Functor f
  => f Float
  -> f Float
conditionFloatF = fmap conditionFloat

-- | One-hot encoded version of 'P.Ordering'. The order of fields is chosen to
-- match the ordering picked by Xilinx's Floating Point comparison IP.
data Ordering
  = EQ
  | LT
  | GT
  | NaN
  deriving (Generic, NFDataX, Eq, ShowX, Show, Lift)
deriveAnnotation (simpleDerivator OneHot Wide) [t| Ordering |]
deriveBitPack [t| Ordering |]

-- | Converts 'Ordering' to Prelude's 'P.Ordering'. If the given ordering is
-- 'NaN', 'Nothing' is returned.
toMaybeOrdering :: Ordering -> Maybe P.Ordering
toMaybeOrdering = \case
  EQ -> Just P.EQ
  LT -> Just P.LT
  GT -> Just P.GT
  NaN -> Nothing

-- | Perform comparison on two 'Float's. The type returned is a locally defined
-- version of 'Ordering'. If you want prelude's 'P.Ordering', see 'toMaybeOrdering'.
xilinxCompare :: Float -> Float -> Ordering
xilinxCompare x y
  | isNaN x = NaN
  | isNaN y = NaN
  | otherwise =
      case compare (conditionFloat x) (conditionFloat y) of
        P.LT -> LT
        P.EQ -> EQ
        P.GT -> GT
