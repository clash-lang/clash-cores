{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unused-binds #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# OPTIONS_HADDOCK show-extensions #-}

-- |
--  Copyright   :  (C) 2024, Hoang Minh Le <minhxecole@gmail.com>
--  License     :  BSD2
--  Maintainer  :  QBayLogic B.V. <devops@qbaylogic.com>
--  This module contains haskell templatefunction to generate BlackBoxFunction,
--  BlackBoxTemplateFunction, TemplateFunction, Primitive and InfoEntity of FloPoCo arithmetic operations
module Clash.Cores.ClashFloPoCo.GenTemDSL
  ( getPipeDep,
    flopocoPrim,
    genFloPoCoInfoEntity,
    liftInfoEntity,
    genBlackBoxFunction,
    genTemplateFunction,
    genBlackBoxTemplateFunction,
    genBlackBoxTemplateFunctionProd,
    genBlackBox,
    genBlackBoxProd,
  )
where

import Clash.Annotations.Primitive (Primitive (..))
import Clash.Backend (Backend)
import qualified Clash.Cores.ClashFloPoCo.FloPoCoCall as FPCC
import Clash.Cores.ClashFloPoCo.InfoEn
import Clash.Cores.ClashFloPoCo.Lexer
import Clash.Netlist.BlackBox.Types
  ( BlackBoxFunction,
    BlackBoxMeta (..),
    TemplateKind (..),
    emptyBlackBoxMeta,
  )
import qualified Clash.Netlist.Id as Id
import Clash.Netlist.Types
  ( BlackBox (..),
    BlackBoxContext,
    EntityOrComponent (..),
    TemplateFunction (..),
  )
import qualified Clash.Netlist.Types as NT
import qualified Clash.Primitives.DSL as DSL
import Control.Monad.State (liftIO)
import Control.Monad.State.Lazy (State)
import Data.Char (toLower)
import Data.Maybe (fromMaybe)
import Data.String.Interpolate (__i)
import Data.Text (Text)
import Data.Text.Prettyprint.Doc.Extra (Doc)
import GHC.Stack (HasCallStack)
import Language.Haskell.TH.Syntax
import Text.Show.Pretty (ppShow)
import Prelude

-- | Function to convert pipeline depth from InfoEntity to Nat number
getPipeDep :: InfoEntity -> Q Type
getPipeDep infoen = do
  return (LitT (NumTyLit (fromIntegral (convertMaybeToInt (pipedep infoen)))))

-- | Function to generate the InfoEntity coresponding to the arithmetic entity generated by FloPoCo
--
--  __Example:__
--
--  > floPoCoPath = "/home/user/flopoco/build/bin/flopoco"
--  > args = ["frequency=100", "target=Zynq7000", "IEEEFPAdd", "wE=8", "wF=23","name=plusFloat", "outputFile=flopocoAdd.vhdl","registerLargeTables=1"]
--  > filePath = "flopocoAdd.vhdl"
--  > infoEnplus = $(genFloPoCoInfoEntity floPoCoPath args filePath)
genFloPoCoInfoEntity ::
  -- | path where FloPoCo is built or installed
  String ->
  -- | input to feed FloPoCo
  [String] ->
  -- | Path to the VHDL file generated by FloPoCo
  String ->
  Q Exp
genFloPoCoInfoEntity floPoCoPathName argsName fileName = do
  output <- liftIO $ FPCC.callFloPoCoWithInput floPoCoPathName argsName ""
  if "Error" `elem` lines output
    then fail "Error in FloPoCo output"
    else do
      result <- processVHDLFile getLastInfoEntity fileName
      liftIO $ print result
      case result of
        Just infoentity -> [|$(liftInfoEntity infoentity)|] -- Lift InfoEntity as expression
        Nothing -> fail "Failed to generate InfoEntity"

-- | Helper function to lift InfoEntity to Q Exp (used internally by genFloPoCoInfoEntity)
liftInfoEntity :: InfoEntity -> Q Exp
liftInfoEntity (InfoEntity n f p ins outs) =
  [|InfoEntity $(lift n) $(lift f) $(lift p) $(lift ins) $(lift outs)|]

--
--

-- | Function to generate HDL Primitive for clash
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__
--
--  > {-# ANN plusFloat (flopocoPrim 'plusFloat 'plusFloatBBF) #-}
--  is equavilent to
--
--  > {-# ANN plusFloat (
--  >    let
--  >      primName = show 'plusFloat
--  >      tfName = show 'plusFloatBBF
--  >   in
--  >      InlineYamlPrimitive [minBound..] [__i|
--  >        BlackBoxHaskell:
--  >          name: #{primName}
--  >          templateFunction: #{tfName}
--  >          workInfo: Always
--  >      |]) #-}
flopocoPrim ::
  -- | Name of the Clash function corresponding to entity(VHDL) or module(Verilog, SystemVerilog)
  Name ->
  -- | Name of BlackBox function of the Clash function
  Name ->
  Primitive
flopocoPrim fprimName ftfName =
  let primName = fprimName
      tfName = ftfName
   in InlineYamlPrimitive
        [minBound ..]
        [__i|
        BlackBoxHaskell:
          name: #{primName}
          templateFunction: #{tfName}
          workInfo: Always
        |]

-- | Function to convert Maybe Int to Int
convertMaybeToInt :: Maybe Int -> Int
convertMaybeToInt = fromMaybe 0

-- | Function to generate a black box function with dynamic names
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "plusFloat", freq = Nothing, pipedep = Nothing, insig = Nothing, outsig = Nothing}
-- \$(genBlackBoxFunction infoen)
-- @
--
-- will generate this code during compile time
--
-- @
-- plusFloatBBF :: BlackBoxFunction
--    plusFloatBBF _ _ _ _
--       = pure
--          (Right
--             (emptyBlackBoxMeta {bbKind = TDecl},
--             BBFunction "plusFloatTF" 0 (plusFloatTF "plusFloat")))
-- @
genBlackBoxFunction :: InfoEntity -> Q [Dec]
genBlackBoxFunction infoen = do
  let entityName = fromMaybe "" (name infoen)
  let tfName = mkName (entityName <> "TF")
  let bbfName = mkName (entityName <> "BBF")
  -- Create the function declaration
  let funcDec =
        FunD
          bbfName
          [ Clause
              [WildP, WildP, WildP, WildP]
              ( NormalB
                  ( AppE
                      (VarE 'pure)
                      ( AppE
                          (ConE 'Right)
                          ( TupE
                              [ Just (RecUpdE (VarE 'emptyBlackBoxMeta) [('bbKind, ConE 'TDecl)]),
                                Just
                                  ( AppE
                                      ( AppE
                                          (AppE (ConE 'BBFunction) (LitE (StringL (entityName <> "TF")))) -- 1st arg
                                          (LitE (IntegerL 0)) -- 2nd arg
                                      )
                                      (AppE (VarE tfName) (LitE (StringL entityName))) -- 3rd arg
                                  )
                              ]
                          )
                      )
                  )
              )
              []
          ]

  -- Create the function signature for the black box function
  let funcSig = SigD bbfName (ConT ''BlackBoxFunction) -- Adjust the type to match the function signature

  -- Return both the type signature and the function definition
  return [funcSig, funcDec]

-- | Function to generate Template function for Blackbox and BlackboxTemplateFunction
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "plusFloat", freq = Nothing, pipedep = Nothing, insig = Just ["clk", "X", "Y"], outsig = Nothing}
-- \$(genTemplateFunction infoen)
-- @
--
-- will generate this code during compile time
--
-- @
-- plusFloatTF :: HasCallStack => Text -> TemplateFunction
--    plusFloatTF entityName
--       = TemplateFunction
--          [0, 1, 2, 3] (const True) (plusFloatBBTF entityName)
-- @
genTemplateFunction :: InfoEntity -> Q [Dec]
genTemplateFunction infoen = do
  let entityNamestr = fromMaybe "" (name infoen)
  let tfNamestr = entityNamestr <> "TF"
  let bbtfNamestr = entityNamestr <> "BBTF"
  let tfName = mkName tfNamestr
  let entityNameName = mkName entityNamestr
  let bbtfName = mkName bbtfNamestr
  let lensignal = lengthMaybeStrings (insig infoen)
  -- Create the function definition
  let funcDec =
        FunD
          tfName
          [ Clause
              [VarP entityNameName]
              ( NormalB
                  ( AppE
                      ( AppE
                          (AppE (ConE 'TemplateFunction) (ListE [LitE (IntegerL (toInteger i)) | i <- [0 .. lensignal]])) -- 1st arg
                          (AppE (VarE 'const) (ConE 'True)) -- 2nd arg
                      )
                      (AppE (VarE bbtfName) (VarE entityNameName)) -- 3rd arg
                  )
              )
              []
          ]

  -- Create the type declaration
  let funcSig = SigD tfName (ForallT [] [ConT ''HasCallStack] (AppT (AppT ArrowT (ConT ''Text)) (ConT ''TemplateFunction)))

  -- Return both the type signature and the function definition
  return [funcSig, funcDec]

toLowercaseList :: [String] -> [String]
toLowercaseList = map lowercaseFirst
  where
    lowercaseFirst [] = []
    lowercaseFirst (x : xs) = toLower x : xs

-- | Function to generate BlackBoxTemplateFunction from InfoEntity
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "plusFloat", freq = Nothing, pipedep = Nothing, insig = Just ["clk", "X", "Y"], outsig = Just ["R"]}
-- \$(genBlackBoxTemplateFunction infoen)
-- @
--
-- will generate this code during compile time
--
-- @
-- plusFloatBBTF ::
--       forall s. Backend s => Text -> BlackBoxContext -> State s Doc
-- plusFloatBBTF entityName bbCtx
--       | [clk, x, y] <- L.map fst (DSL.tInputs bbCtx),
--         [r] <- DSL.tResults bbCtx
--       = do plusFloatInstName <- Id.makeBasic "plusFloat_inst"
--            let compInps
--                  = [("clk", DSL.ety clk), ("X", DSL.ety x), ("Y", DSL.ety y)]
--                compOuts = [("R", DSL.ety r)]
--            (DSL.declaration "plusFloat_inst_block"
--               $ (do DSL.compInBlock entityName compInps compOuts
--                     let inps = [("clk", clk), ("X", x), ("Y", y)]
--                         outs = [("R", r)]
--                     DSL.instDecl
--                       Empty (Id.unsafeMake entityName) plusFloatInstName [] inps outs))
--       | otherwise = error (ppShow bbCtx)
-- @
genBlackBoxTemplateFunction :: InfoEntity -> Q [Dec]
genBlackBoxTemplateFunction infoen = do
  let inputNamesListstr = fromMaybe [] (insig infoen)
  let outputNamesListstr = fromMaybe [] (outsig infoen)
  let inputNamesList = (map mkName (toLowercaseList inputNamesListstr))
  let outputNamesList = (map mkName (toLowercaseList outputNamesListstr))
  let entityNamestr = fromMaybe "" (name infoen)
  let entityNameName = mkName (entityNamestr)
  let bbtfName = mkName (entityNamestr <> "BBTF")
  let entityNameInststr = (entityNamestr <> "_inst")
  let entityNameInst = mkName entityNameInststr
  let entityNameInstBlockstr = (entityNamestr <> "_inst_block")
  let entityNameInstBlock = mkName entityNameInstBlockstr
  let entityNameInstNamestr = (entityNamestr <> "InstName")
  let entityNameInstName = mkName entityNameInstNamestr

  let compInps = mkName "compInps"
  let compOuts = mkName "compOuts"

  let inps = mkName "inps"
  let outs = mkName "outs"
  let bbCtx = mkName "bbCtx"
  let s_0 = mkName "s"
  -- Create the function definition
  let funDec =
        FunD
          bbtfName
          [ Clause
              [VarP entityNameName, VarP bbCtx]
              ( GuardedB
                  [ ( PatG
                        [ BindS
                            (ListP [VarP x | x <- inputNamesList])
                            ( AppE
                                (AppE (VarE 'Prelude.map) (VarE 'Prelude.fst))
                                (AppE (VarE 'DSL.tInputs) (VarE bbCtx))
                            ),
                          BindS
                            (ListP [VarP r | r <- outputNamesList])
                            (AppE (VarE 'DSL.tResults) (VarE bbCtx))
                        ],
                      DoE
                        Nothing
                        [ BindS
                            (VarP entityNameInstName)
                            (AppE (VarE 'Id.makeBasic) (LitE (StringL entityNameInststr))),
                          LetS
                            [ ValD
                                (VarP compInps)
                                ( NormalB
                                    ( ListE
                                        [ TupE
                                            [ Just (LitE (StringL x)),
                                              Just (AppE (VarE 'DSL.ety) (VarE y))
                                            ]
                                          | (x, y) <- zip inputNamesListstr inputNamesList
                                        ]
                                    )
                                )
                                [],
                              ValD
                                (VarP compOuts)
                                ( NormalB
                                    ( ListE
                                        [ TupE
                                            [ Just (LitE (StringL x)),
                                              Just (AppE (VarE 'DSL.ety) (VarE y))
                                            ]
                                          | (x, y) <- zip outputNamesListstr outputNamesList
                                        ]
                                    )
                                )
                                []
                            ],
                          NoBindS
                            ( InfixE
                                ( Just
                                    ( AppE
                                        (VarE 'DSL.declaration)
                                        (LitE (StringL entityNameInstBlockstr))
                                    )
                                )
                                (VarE '($))
                                ( Just
                                    ( DoE
                                        Nothing
                                        [ NoBindS
                                            ( AppE
                                                ( AppE
                                                    (AppE (VarE 'DSL.compInBlock) (VarE entityNameName))
                                                    (VarE compInps)
                                                )
                                                (VarE compOuts)
                                            ),
                                          LetS
                                            [ ValD
                                                (VarP inps)
                                                ( NormalB
                                                    ( ListE
                                                        [ TupE [Just (LitE (StringL x)), Just (VarE y)]
                                                          | (x, y) <-
                                                              Prelude.zip
                                                                inputNamesListstr
                                                                inputNamesList
                                                        ]
                                                    )
                                                )
                                                [],
                                              ValD
                                                (VarP outs)
                                                ( NormalB
                                                    ( ListE
                                                        [ TupE [Just (LitE (StringL x)), Just (VarE y)]
                                                          | (x, y) <-
                                                              Prelude.zip
                                                                outputNamesListstr
                                                                outputNamesList
                                                        ]
                                                    )
                                                )
                                                []
                                            ],
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    ( AppE
                                                        ( AppE
                                                            ( AppE
                                                                (AppE (VarE 'DSL.instDecl) (ConE 'NT.Empty))
                                                                ( AppE
                                                                    (VarE 'Id.unsafeMake)
                                                                    (VarE entityNameName)
                                                                )
                                                            )
                                                            (VarE entityNameInstName)
                                                        )
                                                        (ConE '[])
                                                    )
                                                    (VarE inps)
                                                )
                                                (VarE outs)
                                            )
                                        ]
                                    )
                                )
                            )
                        ]
                    ),
                    ( NormalG (VarE 'otherwise),
                      AppE
                        (VarE 'error)
                        (AppE (VarE 'Text.Show.Pretty.ppShow) (VarE bbCtx))
                    )
                  ]
              )
              []
          ]

  let funSig =
        SigD
          bbtfName
          ( ForallT
              [PlainTV s_0 SpecifiedSpec]
              [AppT (ConT ''Clash.Backend.Backend) (VarT s_0)]
              ( AppT
                  (AppT ArrowT (ConT ''Text))
                  ( AppT
                      (AppT ArrowT (ConT ''Clash.Netlist.Types.BlackBoxContext))
                      ( AppT
                          (AppT (ConT ''State) (VarT s_0))
                          (ConT ''Data.Text.Prettyprint.Doc.Extra.Doc)
                      )
                  )
              )
          )

  return [funSig, funDec]

lengthMaybeStrings :: Maybe [String] -> Int
lengthMaybeStrings (Just strs) = length strs
lengthMaybeStrings Nothing = 0

-- | Function to generate BlackBoxFunction, TemplateFunction and BlackBoxTemplateFunction
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "plusFloat", freq = Nothing, pipedep = Nothing, insig = Just ["clk", "X", "Y"], outsig = Just ["R"]}
-- \$(genBlackBox infoen)
-- @
--
-- is equivalent to
--
-- @
-- \$(genBlackBoxTemplateFunction infoen)
-- \$(genTemplateFunction infoen)
-- \$(genBlackBoxFunction infoen)
-- @
--
-- which will generate this code during compile time
--
-- @
-- plusFloatBBTF ::
--       forall s. Backend s => Text -> BlackBoxContext -> State s Doc
-- plusFloatBBTF entityName bbCtx
--       | [clk, x, y] <- L.map fst (DSL.tInputs bbCtx),
--         [r] <- DSL.tResults bbCtx
--       = do plusFloatInstName <- Id.makeBasic "plusFloat_inst"
--            let compInps
--                  = [("clk", DSL.ety clk), ("X", DSL.ety x), ("Y", DSL.ety y)]
--                compOuts = [("R", DSL.ety r)]
--            (DSL.declaration "plusFloat_inst_block"
--               $ (do DSL.compInBlock entityName compInps compOuts
--                     let inps = [("clk", clk), ("X", x), ("Y", y)]
--                         outs = [("R", r)]
--                       DSL.instDecl
--                       Empty (Id.unsafeMake entityName) plusFloatInstName [] inps outs))
--       | otherwise = error (ppShow bbCtx)
-- plusFloatTF :: HasCallStack => Text -> TemplateFunction
-- plusFloatTF entityName
--       = TemplateFunction
--           [0, 1, 2, 3] (const True) (plusFloatBBTF entityName)
-- plusFloatBBF :: BlackBoxFunction
-- plusFloatBBF _ _ _ _
--       = pure
--           (Right
--              (emptyBlackBoxMeta {bbKind = TDecl},
--               BBFunction "plusFloatTF" 0 (plusFloatTF "plusFloat"))
-- @
genBlackBox :: InfoEntity -> Q [Dec]
genBlackBox infoen = do
  let entityNameNamestr = "entityName"
  let entityNameName = mkName entityNameNamestr
  let entityNamestr = fromMaybe "" (name infoen)
  let entityName = mkName entityNamestr

  let inputNamesListstr = fromMaybe [] (insig infoen)
  let outputNamesListstr = fromMaybe [] (outsig infoen)
  let inputNamesList = map mkName (toLowercaseList inputNamesListstr)
  let outputNamesList = map mkName (toLowercaseList outputNamesListstr)

  let bbfNamestr = entityNamestr <> "BBF"
  let bbfName = mkName bbfNamestr
  let tfNamestr = entityNamestr <> "TF"
  let tfName = mkName tfNamestr
  let bbtfNamestr = entityNamestr <> "BBTF"
  let bbtfName = mkName bbtfNamestr

  let entityNameInststr = entityNamestr <> "_inst"
  let entityNameInst = mkName entityNameInststr
  let entityNameInstBlockstr = entityNamestr <> "_inst_block"
  let entityNameInstBlock = mkName entityNameInstBlockstr
  let entityNameInstNamestr = entityNamestr <> "InstName"
  let entityNameInstName = mkName entityNameInstNamestr

  let compInps = mkName "compInps"
  let compOuts = mkName "compOuts"

  let inps = mkName "inps"
  let outs = mkName "outs"
  let bbCtx = mkName "bbCtx"
  let s = mkName "s"

  let lensignal = lengthMaybeStrings (insig infoen)
  -- Create BlackBoxTemplateFunction definition declaration
  let bbtffunDec =
        FunD
          bbtfName
          [ Clause
              [VarP entityNameName, VarP bbCtx]
              ( GuardedB
                  [ ( PatG
                        [ BindS
                            (ListP [VarP x | x <- inputNamesList])
                            ( AppE
                                (AppE (VarE 'Prelude.map) (VarE 'Prelude.fst))
                                (AppE (VarE 'DSL.tInputs) (VarE bbCtx))
                            ),
                          BindS
                            (ListP [VarP r | r <- outputNamesList])
                            (AppE (VarE 'DSL.tResults) (VarE bbCtx))
                        ],
                      DoE
                        Nothing
                        [ BindS
                            (VarP entityNameInstName)
                            (AppE (VarE 'Id.makeBasic) (LitE (StringL entityNameInststr))),
                          LetS
                            [ ValD
                                (VarP compInps)
                                ( NormalB
                                    ( ListE
                                        [ TupE
                                            [ Just (LitE (StringL x)),
                                              Just (AppE (VarE 'DSL.ety) (VarE y))
                                            ]
                                          | (x, y) <- zip inputNamesListstr inputNamesList
                                        ]
                                    )
                                )
                                [],
                              ValD
                                (VarP compOuts)
                                ( NormalB
                                    ( ListE
                                        [ TupE
                                            [ Just (LitE (StringL x)),
                                              Just (AppE (VarE 'DSL.ety) (VarE y))
                                            ]
                                          | (x, y) <- zip outputNamesListstr outputNamesList
                                        ]
                                    )
                                )
                                []
                            ],
                          NoBindS
                            ( InfixE
                                ( Just
                                    ( AppE
                                        (VarE 'DSL.declaration)
                                        (LitE (StringL entityNameInstBlockstr))
                                    )
                                )
                                (VarE '($))
                                ( Just
                                    ( DoE
                                        Nothing
                                        [ NoBindS
                                            ( AppE
                                                ( AppE
                                                    (AppE (VarE 'DSL.compInBlock) (VarE entityNameName))
                                                    (VarE compInps)
                                                )
                                                (VarE compOuts)
                                            ),
                                          LetS
                                            [ ValD
                                                (VarP inps)
                                                ( NormalB
                                                    ( ListE
                                                        [ TupE [Just (LitE (StringL x)), Just (VarE y)]
                                                          | (x, y) <-
                                                              Prelude.zip
                                                                inputNamesListstr
                                                                inputNamesList
                                                        ]
                                                    )
                                                )
                                                [],
                                              ValD
                                                (VarP outs)
                                                ( NormalB
                                                    ( ListE
                                                        [ TupE [Just (LitE (StringL x)), Just (VarE y)]
                                                          | (x, y) <-
                                                              Prelude.zip
                                                                outputNamesListstr
                                                                outputNamesList
                                                        ]
                                                    )
                                                )
                                                []
                                            ],
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    ( AppE
                                                        ( AppE
                                                            ( AppE
                                                                (AppE (VarE 'DSL.instDecl) (ConE 'NT.Empty))
                                                                ( AppE
                                                                    (VarE 'Id.unsafeMake)
                                                                    (VarE entityNameName)
                                                                )
                                                            )
                                                            (VarE entityNameInstName)
                                                        )
                                                        (ConE '[])
                                                    )
                                                    (VarE inps)
                                                )
                                                (VarE outs)
                                            )
                                        ]
                                    )
                                )
                            )
                        ]
                    ),
                    ( NormalG (VarE 'otherwise),
                      AppE
                        (VarE 'error)
                        (AppE (VarE 'Text.Show.Pretty.ppShow) (VarE bbCtx))
                    )
                  ]
              )
              []
          ]

  -- Create BlackBoxTemplateFunction signature declaration
  let bbtffunSig =
        SigD
          bbtfName
          ( ForallT
              [PlainTV s SpecifiedSpec]
              [AppT (ConT ''Clash.Backend.Backend) (VarT s)]
              ( AppT
                  (AppT ArrowT (ConT ''Text))
                  ( AppT
                      (AppT ArrowT (ConT ''Clash.Netlist.Types.BlackBoxContext))
                      ( AppT
                          (AppT (ConT ''State) (VarT s))
                          (ConT ''Data.Text.Prettyprint.Doc.Extra.Doc)
                      )
                  )
              )
          )
  -- Create TemplateFunction definition declaration
  let tffuncDec =
        FunD
          tfName
          [ Clause
              [VarP entityNameName]
              ( NormalB
                  ( AppE
                      ( AppE
                          (AppE (ConE 'TemplateFunction) (ListE [LitE (IntegerL (toInteger i)) | i <- [0 .. lensignal]])) -- 1st arg
                          (AppE (VarE 'const) (ConE 'True)) -- 2nd arg
                      )
                      (AppE (VarE bbtfName) (VarE entityNameName)) -- 3rd arg
                  )
              )
              []
          ]

  -- Create TemplateFunction signature declaration
  let tffuncSig = SigD tfName (ForallT [] [ConT ''HasCallStack] (AppT (AppT ArrowT (ConT ''Text)) (ConT ''TemplateFunction)))
  -- Create BlackBoxFunction definition declaration
  let bbffuncDec =
        FunD
          bbfName
          [ Clause
              [WildP, WildP, WildP, WildP]
              ( NormalB
                  ( AppE
                      (VarE 'pure)
                      ( AppE
                          (ConE 'Right)
                          ( TupE
                              [ Just (RecUpdE (VarE 'emptyBlackBoxMeta) [('bbKind, ConE 'TDecl)]),
                                Just
                                  ( AppE
                                      ( AppE
                                          (AppE (ConE 'BBFunction) (LitE (StringL tfNamestr))) -- 1st arg
                                          (LitE (IntegerL 0)) -- 2nd arg
                                      )
                                      (AppE (VarE tfName) (LitE (StringL entityNamestr))) -- 3rd arg
                                  )
                              ]
                          )
                      )
                  )
              )
              []
          ]

  -- Create the function signature for the black box function
  let bbffuncSig = SigD bbfName (ConT ''BlackBoxFunction) -- Adjust the type to match the function signature
  return [bbtffunSig, bbtffunDec, tffuncSig, tffuncDec, bbffuncSig, bbffuncDec]

-- | This function to generate BlackBoxTemplateFunction for the InfoEntity in the case that there is more than one output signal
--
--  Please see the source file if cannot see the content of the example
--
--  ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "vga_controller",
--          freq = Nothing,
--          pipedep = Nothing,
--          insig = Just ["clk_100MHz", "reset"],
--          outsig = Just  ["video_on", "hsync", "vsync", "p_tick", "x", "y"] }
-- \$(genBlackBoxTemplateFunctionProd infoen)
-- @
--
-- will generate this code during compile time
--
-- @
-- vga_controllerBBTF ::
--       forall s. Backend s => Text -> BlackBoxContext -> State s Doc
-- vga_controllerBBTF entityName bbCtx
--       | [clk_100MHz, reset] <- L.map fst (DSL.tInputs bbCtx),
--         [result] <- DSL.tResults bbCtx,
--         NT.Product _ _ resTyps <- DSL.ety result
--       = do vga_controllerInstName <- Id.makeBasic "vga_controller_inst"
--            let compInps
--                  = [("clk_100MHz", DSL.ety clk_100MHz), ("reset", DSL.ety reset)]
--                compOuts
--                  = L.zip ["video_on", "hsync", "vsync", "p_tick", "x", "y"] resTyps
--            (DSL.declarationReturn bbCtx "vga_controller_inst_block"
--               $ (do declares <- mapM
--                                   (\ (outname, typ) -> DSL.declare outname typ)
--                                   (L.zip ["video_on", "hsync", "vsync", "p_tick", "x", "y"] resTyps)
--                     let [video_on, hsync, vsync, p_tick, x, y] = declares
--                     let inps = [("clk_100MHz", clk_100MHz), ("reset", reset)]
--                         outs
--                           = [("video_on", video_on), ("hsync", hsync), ("vsync", vsync),
--                              ("p_tick", p_tick), ("x", x), ("y", y)]
--                     DSL.compInBlock entityName compInps compOuts
--                     DSL.instDecl
--                       Empty (Id.unsafeMake entityName) vga_controllerInstName [] inps
--                       outs
--                     pure
--                       [DSL.constructProduct
--                          (DSL.ety result) [video_on, hsync, vsync, p_tick, x, y]]))
--       | otherwise = error (ppShow bbCtx)
-- @
genBlackBoxTemplateFunctionProd :: InfoEntity -> Q [Dec]
genBlackBoxTemplateFunctionProd infoen = do
  let entityNameNamestr = "entityName"
  let entityNameName = mkName entityNameNamestr
  let entityNamestr = fromMaybe "" (name infoen)
  let entityName = mkName entityNamestr

  let inputNamesListstr = fromMaybe [] (insig infoen)
  let outputNamesListstr = fromMaybe [] (outsig infoen)
  let inputNamesList = map mkName (toLowercaseList inputNamesListstr)
  let outputNamesList = map mkName (toLowercaseList outputNamesListstr)

  let bbfNamestr = entityNamestr <> "BBF"
  let bbfName = mkName bbfNamestr
  let tfNamestr = entityNamestr <> "TF"
  let tfName = mkName tfNamestr
  let bbtfNamestr = entityNamestr <> "BBTF"
  let bbtfName = mkName bbtfNamestr

  let entityNameInststr = entityNamestr <> "_inst"
  let entityNameInst = mkName entityNameInststr
  let entityNameInstBlockstr = entityNamestr <> "_inst_block"
  let entityNameInstBlock = mkName entityNameInstBlockstr
  let entityNameInstNamestr = entityNamestr <> "InstName"
  let entityNameInstName = mkName entityNameInstNamestr

  let compInps = mkName "compInps"
  let compOuts = mkName "compOuts"

  let inps = mkName "inps"
  let outs = mkName "outs"
  let bbCtx = mkName "bbCtx"
  let s = mkName "s"
  let result = mkName "result"
  let resTyps = mkName "resTyps"
  let declares = mkName "declares"
  let outname = mkName "outname"
  let typ = mkName "typ"

  let bbtffunDec =
        FunD
          bbtfName
          [ Clause
              [VarP entityNameName, VarP bbCtx]
              ( GuardedB
                  [ ( PatG
                        [ BindS
                            (ListP [VarP x | x <- inputNamesList])
                            ( AppE
                                (AppE (VarE 'Prelude.map) (VarE 'Prelude.fst))
                                (AppE (VarE 'DSL.tInputs) (VarE bbCtx))
                            ),
                          BindS (ListP [VarP result]) (AppE (VarE 'DSL.tResults) (VarE bbCtx)),
                          BindS (ConP 'NT.Product [] [WildP, WildP, VarP resTyps]) (AppE (VarE 'DSL.ety) (VarE result))
                        ],
                      DoE
                        Nothing
                        [ BindS
                            (VarP entityNameInstName)
                            (AppE (VarE 'Id.makeBasic) (LitE (StringL entityNameInststr))),
                          LetS
                            [ ValD
                                (VarP compInps)
                                ( NormalB
                                    ( ListE
                                        [TupE [Just (LitE (StringL x)), Just (AppE (VarE 'DSL.ety) (VarE y))] | (x, y) <- zip inputNamesListstr inputNamesList]
                                    )
                                )
                                [],
                              ValD
                                (VarP compOuts)
                                ( NormalB
                                    ( AppE
                                        ( AppE
                                            (VarE 'zip)
                                            (ListE [LitE (StringL x) | x <- outputNamesListstr])
                                        )
                                        (VarE resTyps)
                                    )
                                )
                                []
                            ],
                          NoBindS
                            ( InfixE
                                ( Just
                                    ( AppE
                                        (AppE (VarE 'DSL.declarationReturn) (VarE bbCtx))
                                        (LitE (StringL entityNameInstBlockstr))
                                    )
                                )
                                (VarE '($))
                                ( Just
                                    ( DoE
                                        Nothing
                                        [ BindS
                                            (VarP declares)
                                            ( AppE
                                                ( AppE
                                                    (VarE 'Prelude.mapM)
                                                    (LamE [TupP [VarP outname, VarP typ]] (AppE (AppE (VarE 'DSL.declare) (VarE outname)) (VarE typ)))
                                                )
                                                ( AppE
                                                    ( AppE
                                                        (VarE 'Prelude.zip)
                                                        (ListE [LitE (StringL x) | x <- outputNamesListstr])
                                                    )
                                                    (VarE resTyps)
                                                )
                                            ),
                                          LetS
                                            [ ValD
                                                (ListP [VarP x | x <- outputNamesList])
                                                (NormalB (VarE declares))
                                                []
                                            ],
                                          LetS
                                            [ ValD
                                                (VarP inps)
                                                ( NormalB
                                                    (ListE [TupE [Just (LitE (StringL x)), Just (VarE y)] | (x, y) <- zip inputNamesListstr inputNamesList])
                                                )
                                                [],
                                              ValD
                                                (VarP outs)
                                                ( NormalB
                                                    (ListE [TupE [Just (LitE (StringL x)), Just (VarE y)] | (x, y) <- zip outputNamesListstr outputNamesList])
                                                )
                                                []
                                            ],
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    (AppE (VarE 'DSL.compInBlock) (VarE entityNameName))
                                                    (VarE compInps)
                                                )
                                                (VarE compOuts)
                                            ),
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    ( AppE
                                                        ( AppE
                                                            ( AppE
                                                                (AppE (VarE 'DSL.instDecl) (ConE 'Empty))
                                                                (AppE (VarE 'Id.unsafeMake) (VarE entityNameName))
                                                            )
                                                            (VarE entityNameInstName)
                                                        )
                                                        (ConE '[])
                                                    )
                                                    (VarE inps)
                                                )
                                                (VarE outs)
                                            ),
                                          NoBindS
                                            ( AppE
                                                (VarE 'pure)
                                                ( ListE
                                                    [ AppE
                                                        ( AppE
                                                            (VarE 'DSL.constructProduct)
                                                            (AppE (VarE 'DSL.ety) (VarE result))
                                                        )
                                                        (ListE [VarE x | x <- outputNamesList])
                                                    ]
                                                )
                                            )
                                        ]
                                    )
                                )
                            )
                        ]
                    ),
                    (NormalG (VarE 'otherwise), AppE (VarE 'error) (AppE (VarE 'ppShow) (VarE bbCtx)))
                  ]
              )
              []
          ]

  let bbtffunSig = SigD bbtfName (ForallT [PlainTV s SpecifiedSpec] [AppT (ConT ''Clash.Backend.Backend) (VarT s)] (AppT (AppT ArrowT (ConT ''Text)) (AppT (AppT ArrowT (ConT ''Clash.Netlist.Types.BlackBoxContext)) (AppT (AppT (ConT ''State) (VarT s)) (ConT ''Data.Text.Prettyprint.Doc.Extra.Doc)))))

  return [bbtffunSig, bbtffunDec]

--

-- | This is the function to generate BlackBoxFunction, TemplateFunction and BlackBoxTemplateFunction
--  in case that the InfoEntity contains multiple output signals
--
--  Please see the source file if cannot see the content of the example
--
-- ==== __Example:__

-- |
-- @
-- infoen = InfoEntity {name = Just "vga_controller",
--          freq = Nothing,
--          pipedep = Nothing,
--          insig = Just ["clk_100MHz", "reset"],
--          outsig = Just  ["video_on", "hsync", "vsync", "p_tick", "x", "y"] }
-- \$(genBlackBoxProd infoen)
-- @
--
-- is equivalent to
--
-- @
-- \$(genBlackBoxTemplateFunctionProd infoen)
-- \$(genTemplateFunction infoen)
-- \$(genBlackBoxFunction infoen)
-- @
--
-- which will generate this code during compile time
--
-- @
-- vga_controllerBBTF ::
--       forall s. Backend s => Text -> BlackBoxContext -> State s Doc
-- vga_controllerBBTF entityName bbCtx
--       | [clk_100MHz, reset] <- L.map fst (DSL.tInputs bbCtx),
--         [result] <- DSL.tResults bbCtx,
--         NT.Product _ _ resTyps <- DSL.ety result
--       = do vga_controllerInstName <- Id.makeBasic "vga_controller_inst"
--            let compInps
--                  = [("clk_100MHz", DSL.ety clk_100MHz), ("reset", DSL.ety reset)]
--                compOuts
--                  = L.zip ["video_on", "hsync", "vsync", "p_tick", "x", "y"] resTyps
--            (DSL.declarationReturn bbCtx "vga_controller_inst_block"
--               $ (do declares <- mapM
--                                   (\ (outname, typ) -> DSL.declare outname typ)
--                                   (L.zip ["video_on", "hsync", "vsync", "p_tick", "x", "y"] resTyps)
--                     let [video_on, hsync, vsync, p_tick, x, y] = declares
--                     let inps = [("clk_100MHz", clk_100MHz), ("reset", reset)]
--                         outs
--                           = [("video_on", video_on), ("hsync", hsync), ("vsync", vsync),
--                              ("p_tick", p_tick), ("x", x), ("y", y)]
--                     DSL.compInBlock entityName compInps compOuts
--                     DSL.instDecl
--                       Empty (Id.unsafeMake entityName) vga_controllerInstName [] inps
--                       outs
--                     pure
--                       [DSL.constructProduct
--                          (DSL.ety result) [video_on, hsync, vsync, p_tick, x, y]]))
--       | otherwise = error (ppShow bbCtx)
-- vga_controllerTF :: HasCallStack => Text -> TemplateFunction
-- vga_controllerTF entityName
--       = TemplateFunction
--           [0, 1, 2] (const True) (vga_controllerBBTF entityName)
-- vga_controllerBBF :: BlackBoxFunction
-- vga_controllerBBF _ _ _ _
--       = pure
--           (Right
--              (emptyBlackBoxMeta {bbKind = TDecl},
--               BBFunction
--                 "vga_controllerTF" 0 (vga_controllerTF "vga_controller")))
-- @
genBlackBoxProd :: InfoEntity -> Q [Dec]
genBlackBoxProd infoen = do
  let entityNameNamestr = "entityName"
  let entityNameName = mkName entityNameNamestr
  let entityNamestr = fromMaybe "" (name infoen)
  let entityName = mkName entityNamestr

  let inputNamesListstr = fromMaybe [] (insig infoen)
  let outputNamesListstr = fromMaybe [] (outsig infoen)
  let inputNamesList = map mkName (toLowercaseList inputNamesListstr)
  let outputNamesList = map mkName (toLowercaseList outputNamesListstr)

  let bbfNamestr = entityNamestr <> "BBF"
  let bbfName = mkName bbfNamestr
  let tfNamestr = entityNamestr <> "TF"
  let tfName = mkName tfNamestr
  let bbtfNamestr = entityNamestr <> "BBTF"
  let bbtfName = mkName bbtfNamestr

  let entityNameInststr = entityNamestr <> "_inst"
  let entityNameInst = mkName entityNameInststr
  let entityNameInstBlockstr = entityNamestr <> "_inst_block"
  let entityNameInstBlock = mkName entityNameInstBlockstr
  let entityNameInstNamestr = entityNamestr <> "InstName"
  let entityNameInstName = mkName entityNameInstNamestr

  let compInps = mkName "compInps"
  let compOuts = mkName "compOuts"

  let inps = mkName "inps"
  let outs = mkName "outs"
  let bbCtx = mkName "bbCtx"
  let s = mkName "s"
  let result = mkName "result"
  let resTyps = mkName "resTyps"
  let declares = mkName "declares"
  let outname = mkName "outname"
  let typ = mkName "typ"

  let lensignal = lengthMaybeStrings (insig infoen)

  let bbtffunDec =
        FunD
          bbtfName
          [ Clause
              [VarP entityNameName, VarP bbCtx]
              ( GuardedB
                  [ ( PatG
                        [ BindS
                            (ListP [VarP x | x <- inputNamesList])
                            ( AppE
                                (AppE (VarE 'Prelude.map) (VarE 'Prelude.fst))
                                (AppE (VarE 'DSL.tInputs) (VarE bbCtx))
                            ),
                          BindS (ListP [VarP result]) (AppE (VarE 'DSL.tResults) (VarE bbCtx)),
                          BindS (ConP 'NT.Product [] [WildP, WildP, VarP resTyps]) (AppE (VarE 'DSL.ety) (VarE result))
                        ],
                      DoE
                        Nothing
                        [ BindS
                            (VarP entityNameInstName)
                            (AppE (VarE 'Id.makeBasic) (LitE (StringL entityNameInststr))),
                          LetS
                            [ ValD
                                (VarP compInps)
                                ( NormalB
                                    ( ListE
                                        [TupE [Just (LitE (StringL x)), Just (AppE (VarE 'DSL.ety) (VarE y))] | (x, y) <- zip inputNamesListstr inputNamesList]
                                    )
                                )
                                [],
                              ValD
                                (VarP compOuts)
                                ( NormalB
                                    ( AppE
                                        ( AppE
                                            (VarE 'zip)
                                            (ListE [LitE (StringL x) | x <- outputNamesListstr])
                                        )
                                        (VarE resTyps)
                                    )
                                )
                                []
                            ],
                          NoBindS
                            ( InfixE
                                ( Just
                                    ( AppE
                                        (AppE (VarE 'DSL.declarationReturn) (VarE bbCtx))
                                        (LitE (StringL entityNameInstBlockstr))
                                    )
                                )
                                (VarE '($))
                                ( Just
                                    ( DoE
                                        Nothing
                                        [ BindS
                                            (VarP declares)
                                            ( AppE
                                                ( AppE
                                                    (VarE 'Prelude.mapM)
                                                    (LamE [TupP [VarP outname, VarP typ]] (AppE (AppE (VarE 'DSL.declare) (VarE outname)) (VarE typ)))
                                                )
                                                ( AppE
                                                    ( AppE
                                                        (VarE 'Prelude.zip)
                                                        (ListE [LitE (StringL x) | x <- outputNamesListstr])
                                                    )
                                                    (VarE resTyps)
                                                )
                                            ),
                                          LetS
                                            [ ValD
                                                (ListP [VarP x | x <- outputNamesList])
                                                (NormalB (VarE declares))
                                                []
                                            ],
                                          LetS
                                            [ ValD
                                                (VarP inps)
                                                ( NormalB
                                                    (ListE [TupE [Just (LitE (StringL x)), Just (VarE y)] | (x, y) <- zip inputNamesListstr inputNamesList])
                                                )
                                                [],
                                              ValD
                                                (VarP outs)
                                                ( NormalB
                                                    (ListE [TupE [Just (LitE (StringL x)), Just (VarE y)] | (x, y) <- zip outputNamesListstr outputNamesList])
                                                )
                                                []
                                            ],
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    (AppE (VarE 'DSL.compInBlock) (VarE entityNameName))
                                                    (VarE compInps)
                                                )
                                                (VarE compOuts)
                                            ),
                                          NoBindS
                                            ( AppE
                                                ( AppE
                                                    ( AppE
                                                        ( AppE
                                                            ( AppE
                                                                (AppE (VarE 'DSL.instDecl) (ConE 'Empty))
                                                                (AppE (VarE 'Id.unsafeMake) (VarE entityNameName))
                                                            )
                                                            (VarE entityNameInstName)
                                                        )
                                                        (ConE '[])
                                                    )
                                                    (VarE inps)
                                                )
                                                (VarE outs)
                                            ),
                                          NoBindS
                                            ( AppE
                                                (VarE 'pure)
                                                ( ListE
                                                    [ AppE
                                                        ( AppE
                                                            (VarE 'DSL.constructProduct)
                                                            (AppE (VarE 'DSL.ety) (VarE result))
                                                        )
                                                        (ListE [VarE x | x <- outputNamesList])
                                                    ]
                                                )
                                            )
                                        ]
                                    )
                                )
                            )
                        ]
                    ),
                    (NormalG (VarE 'otherwise), AppE (VarE 'error) (AppE (VarE 'ppShow) (VarE bbCtx)))
                  ]
              )
              []
          ]

  let bbtffunSig = SigD bbtfName (ForallT [PlainTV s SpecifiedSpec] [AppT (ConT ''Clash.Backend.Backend) (VarT s)] (AppT (AppT ArrowT (ConT ''Text)) (AppT (AppT ArrowT (ConT ''Clash.Netlist.Types.BlackBoxContext)) (AppT (AppT (ConT ''State) (VarT s)) (ConT ''Data.Text.Prettyprint.Doc.Extra.Doc)))))

  -- Create TemplateFunction definition declaration
  let tffuncDec =
        FunD
          tfName
          [ Clause
              [VarP entityNameName]
              ( NormalB
                  ( AppE
                      ( AppE
                          (AppE (ConE 'TemplateFunction) (ListE [LitE (IntegerL (toInteger i)) | i <- [0 .. lensignal]])) -- 1st arg
                          (AppE (VarE 'const) (ConE 'True)) -- 2nd arg
                      )
                      (AppE (VarE bbtfName) (VarE entityNameName)) -- 3rd arg
                  )
              )
              []
          ]

  -- Create TemplateFunction signature declaration
  let tffuncSig = SigD tfName (ForallT [] [ConT ''HasCallStack] (AppT (AppT ArrowT (ConT ''Text)) (ConT ''TemplateFunction)))
  -- Create BlackBoxFunction definition declaration
  let bbffuncDec =
        FunD
          bbfName
          [ Clause
              [WildP, WildP, WildP, WildP]
              ( NormalB
                  ( AppE
                      (VarE 'pure)
                      ( AppE
                          (ConE 'Right)
                          ( TupE
                              [ Just (RecUpdE (VarE 'emptyBlackBoxMeta) [('bbKind, ConE 'TDecl)]),
                                Just
                                  ( AppE
                                      ( AppE
                                          (AppE (ConE 'BBFunction) (LitE (StringL tfNamestr))) -- 1st arg
                                          (LitE (IntegerL 0)) -- 2nd arg
                                      )
                                      (AppE (VarE tfName) (LitE (StringL entityNamestr))) -- 3rd arg
                                  )
                              ]
                          )
                      )
                  )
              )
              []
          ]

  -- Create the function signature for the black box function
  let bbffuncSig = SigD bbfName (ConT ''BlackBoxFunction) -- Adjust the type to match the function signature
  return [bbtffunSig, bbtffunDec, tffuncSig, tffuncDec, bbffuncSig, bbffuncDec]
