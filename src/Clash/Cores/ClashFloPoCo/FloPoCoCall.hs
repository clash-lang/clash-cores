-- |
--  Copyright   :  (C) 2024, Hoang Minh Le <minhxecole@gmail.com>.
--  License     :  BSD2
--  Maintainer  :  QBayLogic B.V. <devops@qbaylogic.com>
module Clash.Cores.ClashFloPoCo.FloPoCoCall
  ( callFloPoCoWithInput, -- add this line to export the function
  )
where

import qualified Control.Monad.Fail as Fail
import Control.Monad.IO.Class (MonadIO, liftIO)
import System.IO (hClose, hFlush, hGetContents, hPutStrLn)
import System.Info (os)
import System.Process
import Prelude

-- | This function is to call FloPoCo to generate VHDL files from provided input
-- Work on Linux. For Window users, it can be used to call FloPoCo
-- directly from WSL without modification
--
-- Example usage with IO:
--
-- > main::IO
-- > main = do
-- >  _ <- callFloPoCoWithInput "/home/user/flopoco/build/bin/flopoco"
-- >                              ["frequency=300", "target=Zynq7000", "FPAdd", "wE=8", "wF=23", "name=SinglePrecisionFPAdd", "registerLargeTables=1"]
-- >                              ""
-- >  return ()
callFloPoCoWithInput ::
  (MonadIO m, Fail.MonadFail m) =>
  -- | The path where FloPoCo is installed or built
  String ->
  -- | List of input for FloPoCo
  [String] ->
  -- | Dummy input
  String ->
  -- | Return the output generated by FloPoCo
  m String
callFloPoCoWithInput floPoCoPath args dummyinput = do
  let (command, finalArgs) =
        if os == "mingw32"
          then ("wsl", floPoCoPath : args) -- On Windows, prepend "wsl"
          else (floPoCoPath, args) -- On Linux, use the binary directly

  -- Create the process with stdin, stdout, stderr pipes
  (Just hin, Just hout, Just herr, _) <-
    liftIO $
      createProcess
        (proc command finalArgs)
          { std_in = CreatePipe,
            std_out = CreatePipe,
            std_err = CreatePipe
          }

  -- Feed input to the process
  liftIO $ do
    hPutStrLn hin dummyinput
    hFlush hin
    hClose hin

  -- Read output from stdout
  output <- liftIO $ hGetContents hout

  -- Optionally print the output (for debugging purposes)
  -- liftIO $ putStrLn output

  -- Read error output from stderr (optional, for debugging)
  errOutput <- liftIO $ hGetContents herr
  liftIO $ putStrLn errOutput

  -- Return the actual output as the result
  return output
