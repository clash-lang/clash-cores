{-|
  Copyright   :  (C) 2021, LUMI GUIDE FIETSDETECTIE B.V.
                     2024, QBayLogic B.V.
  License     :  BSD2 (see the file LICENSE)
  Maintainer  :  QBayLogic B.V. <devops@qbaylogic.com>

  UART transmitter and receiver tests
-}

{-# LANGUAGE NumericUnderscores #-}
{-# OPTIONS_GHC -Wno-orphans #-}

module Test.Cores.UART where

import qualified Data.List as List
import           Data.Maybe
import           Test.Tasty
import qualified Test.Tasty.QuickCheck as QC

import           Clash.Prelude (exposeClockResetEnable)
import           Clash.Explicit.Prelude hiding (interleave)

import           Clash.Cores.UART

-- | Create a 100 MHz domain instead of relying on the default period of System.
createDomain vSystem{vName="System100", vPeriod=10000}

toMaybe :: Bool -> a -> Maybe a
toMaybe True a = Just a
toMaybe False _ = Nothing

-- | Ensures the uart clock scaler has <0.625% error over a single uart "session"
-- We use a baud of 6064281 because a single supersampled
-- uart period(transmitting/receiving a single bit) takes 16.49 clock cycles.
-- This is the worst cases for errors since a mismatch of a single
-- clock cycles has the highest impact.
baudGeneratorErr
  :: forall (baud :: Nat)
   . ValidBaud System100 baud
  => SNat baud
  -> Bool
baudGeneratorErr baud@SNat = errPercent <= 0.625
  where
    clock100Period = snatToNum @Int (clockPeriod @System100)
    uartPeriod = snatToNum @Int $ SNat @(HzToPeriod baud)
    (clk, rst, en) = (clockGen @System100, resetGen, enableGen)
    uartEn = baudGenToSignal
               $ exposeClockResetEnable
                   (baudGenerator baud)
                   clk rst en
    cntNMatches _ _ [] = 0
    cntNMatches n f (x:xs)
      | n <= 0    = 0
      | f x       = 1 + (cntNMatches (n - 1) f xs)
      | otherwise = 1 + (cntNMatches n f xs)
    samples = List.drop 1 $ List.dropWhile not $ sample uartEn
    fndFullPeriod = clock100Period * (cntNMatches (160 :: Int) id samples)
    expFullPeriod = 10 * uartPeriod
    err :: Double
    err = (fromIntegral expFullPeriod) / (fromIntegral fndFullPeriod) - 1.0
    errPercent = 100.0 * (abs err)

-- | Test whether the periods between the ticks generated by the
-- baudGenerator are at most one clock cycle off from one another.
baudGeneratorDeltaPeriod0or1
  :: forall (baud :: Nat)
   . ValidBaud System100 baud
  => SNat baud
  -> Bool
baudGeneratorDeltaPeriod0or1 baud@SNat = ok
  where
    (clk, rst, en) = (clockGen @System100, resetGen, enableGen)
    uartEn = baudGenToSignal
               $ exposeClockResetEnable
                   (baudGenerator baud)
                   clk rst en
    periodLengths bs = go (1 :: Int) (List.drop 1 $ List.dropWhile not bs)
      where go _ [] = []
            go n (True:xs) = n:(go 1 xs)
            go n (False:xs) = go (n + 1) xs

    ok = case (List.nub $ List.take 100 $ periodLengths $ sample uartEn) of
      [_]   -> True
      [a,b] -> abs (a - b) <= 1
      _     -> False

-- | Test that sending a word on the transmitter will correctly be
-- received without changing it.
txRxLoopback
  :: BitVector 8
  -> BitVector 8
  -> Bool
txRxLoopback tx1 tx2 = ok
 where
   baud = SNat @921600
   (clk, rst, en) = (clockGen @System100, resetGen, enableGen)
   uart' = exposeClockResetEnable (uart baud) clk rst en
   (rxWord, txB, ack) = uart' txB txM
   -- Keep tx constant until ack has been received
   ackCnt = register clk rst en 0 $ mux ack (ackCnt + 1) ackCnt
   txN = fmap ([tx1, tx2] List.!!) ackCnt
   txM = liftA2 toMaybe (fmap (<2) ackCnt) txN
   ok = case (catMaybes $ sampleN 2500 rxWord) of
          [rx1, rx2] -> rx1 == tx1 && rx2 == tx2
          _          -> False

-- | Test that the transmitter correctly transmits a word
-- including start and stop bit.
txWord
  :: forall (baud :: Nat)
   . baud ~ 1_562_500
  => BitVector 8
  -> Bool
txWord transmit = txBits == expected
  where
    baud = SNat @baud
    (clk, rst, en) = (systemClockGen, resetGen, enableGen)
    uartTx' = exposeClockResetEnable (uartTx baud) clk rst en
    (txB, ack) = uartTx' txM
    -- Only request a write until ack is received
    ack' = liftA2 (||) ack (register clk rst en False ack')
    txM = mux ack' (pure Nothing) (pure $ Just transmit)
    -- Ensure the transmitted bits have appropiate timing
    uartPeriod = natToNum @(PeriodToCycles System (HzToPeriod baud))
    highBit = List.replicate uartPeriod (1 :: Bit)
    lowBit = List.replicate uartPeriod (0 :: Bit)
    dataBitToList 0 = lowBit
    dataBitToList _ = highBit
    expectedDataBits = List.concat
                         $ List.reverse
                         $ toList
                         $ map dataBitToList $ bv2v transmit
    expected = lowBit List.++ expectedDataBits List.++ highBit

    txBits = List.take (10 * uartPeriod)
               $ List.dropWhile bitToBool
               $ sampleN 1500 txB


-- | Verify that we pick the correct samples in the supersampler.
--
-- The bit rate is chosen such that there are exactly 64 clock periods in every
-- bit period. So there are four clock periods in each supersampling period.
--
-- With @center@ set to the correct value of 9, the supersamples look as
-- follows:
--
-- Supersample  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
-- Start bit  [ 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1]
-- Low bit    [ 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1]
-- High bit   [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
--
-- For a supersampling window of 3 supersamples, the majority vote will only be
-- the desired value if it picks exactly supersamples 8, 9 and 10.
--
-- During debugging, it's useful to adjust @center@ in the code to see if it is
-- picking up a different group.
vfySuperSampling
  :: BitVector 8
  -> Bool
vfySuperSampling recv = ok
  where
    (clk, rst, en) = (clockGen @System100, resetGen, enableGen)
    uartRx' = exposeClockResetEnable (uartRx $ SNat @1_562_500) clk rst en
    -- Which supersampling period is the center of the three.
    center = 9
    startBit :: [Bit]
    startBit = List.concat
                 [ List.take (center - 2) ([0, 0] List.++ List.repeat 1)
                 , [0, 1, 0]
                 , List.replicate (15 - center) 1
                 ]
    dataBit :: Bit -> [Bit]
    dataBit b =
      List.map (xor b)
        $ List.concat
          [ List.replicate (center - 2) 1
          , [0, 1, 0]
          , List.replicate (15 - center) 1
          ]
    stopBit = dataBit 1
    uartInDataBits = List.concat
                       $ List.reverse
                       $ toList
                       $ map dataBit $ bv2v recv
    uartIn = List.concat
               [ [1, 1, 1, 1]
               , startBit
               , uartInDataBits
               , stopBit
               , List.repeat 1
               ]
    rxWord =
      uartRx' $ fromList $ List.concatMap (\d -> List.replicate 4 d) uartIn
    ok = case (catMaybes $ sampleN 2000 rxWord) of
           (rx:_) -> rx == recv
           _      -> False

tests :: TestTree
tests = testGroup "UART"
  [ QC.testProperty "baudGenerator 100 baud <0.625% error"
      $ baudGeneratorErr (SNat @100)
  , QC.testProperty "baudGenerator 4800 baud <0.625% error"
      $ baudGeneratorErr (SNat @4800)
  , QC.testProperty "baudGenerator 9600 baud <0.625% error"
      $ baudGeneratorErr (SNat @9600)
  , QC.testProperty "baudGenerator 115200 baud <0.625% error"
      $ baudGeneratorErr (SNat @115200)
  -- 6064281 is the worst case for the counter baud generation method since with
  -- a 100 Mhz clock every 16.49 cycles a uart cycle occurs.
  , QC.testProperty "baudGenerator 6064281 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorErr (SNat @6064281)
  , QC.testProperty "baudGenerator 100 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorDeltaPeriod0or1 (SNat @100)
  , QC.testProperty "baudGenerator 4800 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorDeltaPeriod0or1 (SNat @4800)
  , QC.testProperty "baudGenerator 9600 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorDeltaPeriod0or1 (SNat @9600)
  , QC.testProperty "baudGenerator 115200 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorDeltaPeriod0or1 (SNat @115200)
  , QC.testProperty "baudGenerator 6064281 baud delta of periods between ticks is 0 or 1"
      $ baudGeneratorDeltaPeriod0or1 (SNat @6064281)
  , QC.testProperty "Loopback tx to rx"
      $ txRxLoopback
  , QC.testProperty "Verify supersampling"
      $ vfySuperSampling
  , QC.testProperty "Transmit word"
      $ txWord
  ]
